<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据库笔记]]></title>
    <url>%2F2019%2F07%2F06%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[数据库NoSQL和SQLSQL（Structured Query Language）数据库，是指关系型数据库 NoSQL（Not Only SQL）数据库，是指非关系型数据库，不同于传统的关系型数据库，NoSQL不使用SQL作为查询语言，数据存储格式也不再需要固定的表格模式，比如使用K-V存储。]]></content>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RSS]]></title>
    <url>%2F2019%2F03%2F28%2Frssreader%2F</url>
    <content type="text"><![CDATA[之前，我是不太了解RSS阅读器的，但是今天忘记在更新自己博客时什么时候给博客加了一个RSS功能，于是非常费解，.hml怎么打开之后的文件打开为什么是乱码。 于是搜索到了一篇2006年的文章： 如何使用RSS 原来是这样的Orz，大概是上一个时代的Subscribe吧 另外，如果你跟我一样，使用了Chrome浏览器，也可以直接在浏览器里搜索到RSS阅读器。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+NexT博客个性化]]></title>
    <url>%2F2019%2F03%2F27%2Fhexonextcomment%2F</url>
    <content type="text"><![CDATA[不定期更新Orz 浏览数量：将next的_config.yml文件设置如下： 123456789101112131415161718192021222324252627#Show PV/UV of the website/page with busuanzi.#Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count:count values only if the other configs are false enable: true# custom uv span for the whole site site_uv: true site_uv_header: 本站访客数 site_uv_footer: 人次# custom pv span for the whole site site_pv: true site_pv_header: 本站总访问量 site_pv_footer: 次# custom pv span for one page only page_pv: true page_pv_header: 本页面共计被访问 page_pv_footer: 次 next主题已经内置了busuanzi可以统计访问量 需要注意的是 next6.0中的busuanzi的地址不对，需要在busuanzi-counter.swig修改相关的相应的新的网址，修改为： 12345678910111213141516171819202122&#123;% if theme.busuanzi_count.enable %&#125;&lt;div class=&quot;busuanzi-count&quot;&gt;&lt;script async src=&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; &#123;% if theme.busuanzi_count.site_uv %&#125; &lt;span class=&quot;site-uv&quot;&gt; &#123;&#123; theme.busuanzi_count.site_uv_header &#125;&#125; &lt;span class=&quot;busuanzi-value&quot; id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt; &#123;&#123; theme.busuanzi_count.site_uv_footer &#125;&#125; &lt;/span&gt; &#123;% endif %&#125; &#123;% if theme.busuanzi_count.site_pv %&#125; &lt;span class=&quot;site-pv&quot;&gt; &#123;&#123; theme.busuanzi_count.site_pv_header &#125;&#125; &lt;span class=&quot;busuanzi-value&quot; id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt; &#123;&#123; theme.busuanzi_count.site_pv_footer &#125;&#125; &lt;/span&gt; &#123;% endif %&#125;&lt;/div&gt;&#123;% endif %&#125; 完成后，效果如下： 评论系统采用了Valine，也可以在最新的next主题内直接使用： 12345678910111213# Valine.# You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: true appid: yourID appkey: yourKEY notify: true # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: 不输入上述信息将触发匿名评论。Comment here. # comment box placeholder avatar: retro # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size 具体方法可以参照： Valine|介绍 值得注意的是，如果你在访问流量的收集时，用到了leancloud，请采用我上述的方式，防止评论系统不可使用，具体原因可以参照下面的网站： https://reuixiy.github.io/technology/computer/computer-aided-art/2018/07/15/use-valine-in-theme-next.html 效果图如下： 现在还未实现发送评论后，立刻给我发送邮件的功能，可以参照下方地址 Valine-Admin/高级配置 解决图片无法加载的问题在hexo中的_config.yml 1`post_asset_folder: true` 重要的是使用相对路径引用的标签插件 例如： 123&#123;% asset_img example.jpg This is an example image %&#125;//或者![](hexonextcomment/2.png)//注意这里没有日期，与保存路径不同 参考： 资源文件夹 这里给大家推荐一个网站背景网站：https://www.toptal.com/designers/subtlepatterns/ 添加阅读全文1&lt;!-- more --&gt; 将上方代码添加到你想要的位置 搜索服务Local Search先安装hexo-generator-searchdb： 1npm install hexo-generator-searchdb --save 然后在站点配置文件，注意不是主题配置，添加以下代码： 12345search: path: search.xml field: post format: html limit: 10000 然后主题配置文件找到local_search改为true，然后从上面提供的样式选一个填入pace_theme中就可以了： 123# Local searchlocal_search: enable: true 菜单栏出现搜索功能。 设置博客字数统计首先cd到blog的目录， 执行 1npm i --save hexo-wordcount 然后 将next的_config.yml文件设置如下： 12345678# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true wordcount: true min2read: false totalcount: true separated_meta: true 效果图： 提交搜索引擎（Google 百度）两个搜索引擎入口：Google搜索引擎提交入口 百度搜索引擎入口。不管谷歌还是百度都要先添加域名，然后验证网站，这里统一都使用文件验证，就是下载对应的html文件，放到域名根目录下，也就收博客根目录下的source/下面 。然后部署到服务器,输入地址：http://chaooo.github.io/google4cc3eef6ff5975bf.html和http://chaooo.github.io/baidu_verify_wjJ25Q3cv2.html能访问到就可以点验证按钮(按照谷歌或百度的引导步骤就好)。注意：若出现验证失败，则是因为hexo编译文件时，会给下载的HTML文件中添加其他的内容，导致验证失败。 这个时候要把相应的文件在hexo中删除，在Github里手动修改验证HTML文件，或者不编译。 修改字体假设Next主题的目录名称为next，如果要自定义CSS样式，只要在themes/next/source/css/_custom/custom.styl文件中写入相应的CSS代码就行了。 注意 文件后缀为styl，猜测可能是使用stylus语法的样式文件。但是我试过了，直接写CSS代码是可行的。 涉及到文件引用的地方要注意路径。如果使用相对路径，默认当前目录为themes/next/source/css/。 注意要执行hexo clean命令，清除已经生成的文件。然后再执行hexo generate重新生成文件。否则样式可能不会生效。 如果页面刷新后，新的样式没有生效，建议检查public/css/main.css中有没有加入新的CSS代码。 自定义字体当前我只能确定支持ttf以及eot格式的字体文件。定义一个字体，首先要确定字体文件的路径。我把字体文件*.ttf放在source/fonts/路径下，hexo生成页面时会把fonts目录复制到public/中。我的网站是建在根目录下的，字体文件引入的路径为/fonts/*.ttf。在themes/next/source/css/_custom/custom.styl文件中加入以下代码，其中font-family的值是你定义的字体的名称，也就是你后面使用字体时的名称。 1234@font-face&#123; font-family: *; src: url(&apos;/fonts/*.ttf&apos;);&#125; 然后要在命令行中执行以下代码 12hexo cleanhexo generate 这样，该样式就能在主题中生效了。如果页面刷新后没有改变，可能是缓存的问题。查看public/css/main.css文件，看看文件末尾有没有新加入的CSS代码。 代码块使用字体既然字体（CSS样式）已经生效了，那就可以在主题中使用该字体了。修改主题配置文件themes/next/_config.yml中codes的配置内容即可。主题会优先使用该字体，当该字体不存在时，会使用其他预设的字体。另外建议把host这一项改为国内的反代理服务器，如//fonts.css.network，以提升访问速度。默认是谷歌的服务器，国内连不上。 123456789101112131415161718192021222324252627282930313233343536373839404142font: enable: true # Uri of fonts host. E.g. //fonts.googleapis.com (Default). host: # Font options: # `external: true` will load this font family from `host` above. # `family: Times New Roman`. Without any quotes. # `size: xx`. Use `px` as unit. # Global font settings used on &lt;body&gt; element. global: external: true family: Lato size: # Font settings for Headlines (h1, h2, h3, h4, h5, h6). # Fallback to `global` font settings. headings: external: true family: size: # Font settings for posts. # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo. # Fallback to `global` font settings. logo: external: true family: Pacifico size: 24 # Font settings for &lt;code&gt; and code blocks. codes: external: true family: size: 然后再执行hexo clean &amp;&amp; hexo generate命令清除并重新生成文件，应该就可以了。 Title格式修改修改位于/themes/next/source/css/_common/components/header的site-meta.styl文件 1234.brand &#123; color: #bfbdef !important;//更改字体颜色 border-bottom: none;//去掉黑条&#125;]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汇编语言]]></title>
    <url>%2F2019%2F03%2F25%2F%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[1.挂载相关的信息mount c /Users/panyumingzhi/masm （注意这里可以使用alt+空格+enter全屏） 将上方代码添加到你想要的位置 搜索服务Local Search先安装hexo-generator-searchdb： 123456789npm install hexo-generator-searchdb --savesearch: path: search.xml field: post format: html limit: 10000# Local searchlocal_search: enable: true 2.转到c:c: 3.定义数据：db 一个字节 dw 一个字表示两个字节 dd 两个字，表示4个字节 dup 表示数据重复的指令db N dup(xx) ; dup表示定义的数据，N表示重复的个数dw N dup(xx) ; dup表示定义的数据，N表示重复的个数dd N dup(xx) ; dup表示定义的数据，N表示重复的个数 4.Debug指令：a:汇编 u:显示写的程序的内容，反汇编 t:单步执行 g:按地址执行 q:退出 R显示或改变一个或多个 CPU 寄存器的内容。 r [register-name] 符号 含义 register-name 指定要显示其内容的寄存器名。 说明：只查看标志的状态，键入命令rf; 要查看所有寄存器的内容、所有标记的状态和当前位置的指令解码表，键入r; D 显示一定范围内存地址的内容。 d [range] 符号 含义 range 指定要显示其内容的内存区域的起始和结束地址，或起始地址和长度。有关有效的 range 值 的信息，请单击“相关主题”列表中的“Debug 说明”。如果不指定 range，Debug 程序将 从以前 d 命令中所指定的地址范围的末尾开始显示 128 个字节的内容。 说明：当使用 d 命令时，Debug 以两个部分显示内存内容:十六进制部分(每个字节的值都用十六 进制格式表示)和 ASCII 码部分(每个字节的值都用 ASCII 码字符表示)。每个非打印字符在显示的 ASCII 部分由句号 (.) 表示。 每个显示行显示 16 字节的内容，第 8 字节和第 9 字节之间有一个连字符。每个显示行从 16 字节的边界上开始。 E:将数据输入到内存中指定的地址。可以按十六进制或 ASCII 格式键入数据。以前存储在指定位置的任何数据全部丢失。 1e address [list] 符号 含义 list 指定要输入到内存的连续字节中的数据。 address 指定输入数据的第一个内存位置。 没有指定可选的 list 参数的值情况下指定 address 的值:Debug 将显示地址和内容，在下一行重复地址，并等待您的输入。此时，可以执行: (1)替换字节值。为此，请在当前值后键入新值。如果键入的值不是有效的十六进制值，或该 值包含两个以上的数字，则 Debug 不会回显无效或额外的字符。 进入下一个字节。为此，请按 SPACEBAR(空格键)。要更改该字节中的值，请在当前值后键 入新值。如果按 SPACEBAR(空格键)时，移动超过了 8 位界限，Debug 程序将显示新的一 行并在行首显示新地址。 (2)返回到前一个字节。为此，请按 HYPHEN 键 (-)。可以反复按 HYPHEN 键 (-) 向后移动超过多个字节。在按 HYPHEN 时，Debug 开始新行并显示当前地址和字节值。 停止执行 e 命令。为此，请按 ENTER 键。在任何字节位置都可以按 ENTER。 使用 list 参数:如果指定 list 参数的值，随后的 e 命令将使用列表中的值替换现有的字节值。如果发生错误，将不更改任何字节值。 List 值可以是十六进制字节或字符串。使用空格、逗号或制表符来分隔值。必须将字符串包 括在单或双引号中。 F:使用指定的值填充指定内存区域中的地址。可以指定十六进制或 ASCII 格式表示的数据。任何以前存储在指定位置的数据将会丢失。 1f range list 符号 含义 range 表示填充内存的的起始位置和终止位置，或起始地址和长度。 list 表示指定的要输入的数据，可由十六进制数或引号包围起来的字符串组成。 说明：(1)如果 range 包含的字节数&gt; list 中的数值，Debug 将在 list 中反复指派值，直到 range 中的所有字节全部填充。 (2)如果在 range 中的任何内存损坏或不存在，Debug 将显示错误消息并停止 f 命令。(3)如果 list 包含的数值多于 range 中的字节数，Debug 将忽略 list 中额外的值。 5.汇编操作符INC和DECINC：加1指令inc a相当于 add a,1 ;i++优点:速度比sub指令快，占用空间小这条指令执行结果影响AF、OF、PF、SF、ZF标志位,但不影响CF进位标志位. DEC：减1指令dec a 相当于sub a,1 优点 速度比sub指令快，占用空间小这条指令执行结果影响AF、OF、PF、SF、ZF标志位,但不影响CF进位标志位. 6.标志位条件码(状态)标志用来记录程序中运行结果的状态信息。 符号 含义 值为1 值为0 OF(Overflow) 溢出标志（指字节(字)运算结果超过了所能表数的范围） 溢出（ov） 未溢出（nv） SF(Sign) 符号标志（与运算结果的最高位相同） 结果为负(ng) 结果为正(pl) ZF(Zero) 零标志 运算结果为零(zr) 运算结果不为零(nz) CF(Carry) 进位标志 最高有效位产生进位或借位(cy) 最高有效位未产生进位或借位(nc) AF(Auxiliary Carry) 辅助进位标志（执行十进制运算指令时，记录运算结果中低半字节(最低4位)向高半字节(即D3向D4)的进位情况。 ） D3向D4有进位或借位(ac) D3向D4没有进位或借位(na) PF(Parity) 奇偶标志（运算结果的低8位中，“1”的个数） 偶数 奇数 控制标志控制标志控制处理器的操作，要通过专门的指令才能使控制标志发生变化 符号 含义 值为1 值为0 DF(Direction) 方向标志(用于控制串操作，指示串操作时操作数地址的增减方向) 串操作后使变址寄存器SI、DI自动减量(dn) 串操作后，使SI、DI自动增量(up) IF(Interrupt) 中断标志（只对外部可屏蔽中断请求(INTR)起作用） 允许CPU响应INTR（ei） 禁止响应INTR(di) TF(Trap) 陷阱标志（用于程序调试） CPU处于单步运行方式 CPU处于正常工作方式 7.寄存器AX BX CX DX是CPU内部的通用寄存器中的数据寄存器,数据寄存器一般用于存放参与运算的数据或运算的结果,每一个数据寄存器都是16位的(即16个二进制位),但又可以将高,低8位分别作为两个独立的8位寄存器使用.它们的高8位记作AH,BH,CH,DH,低8位记作AL,BL,CL,DL.这种灵活的使用方法给编程带来极大的方便,既可以处理16位数据,也能处理8位数据.]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用YCSB测试LevelDB的性能]]></title>
    <url>%2F2019%2F03%2F25%2F%E4%BD%BF%E7%94%A8YCSB%E6%B5%8B%E8%AF%95LevelDB%E7%9A%84%E6%80%A7%E8%83%BD%2F</url>
    <content type="text"><![CDATA[#使用YCSB测试LevelDB的性能 使用LevelDB的接口连接至YCSB，与YCSB的接口连接实现测试性能。 LevelDB接口中文介绍 YCSB接入新的数据库的方法 最后在GitHub上找到了使用YCSB1.4.0版本的ycsb-leveldb 使用命令 mvn -pl com.yahoo.ycsb:leveldb-binding -am clean package 对文件进行编译 之后由于此文档中把ycsb生成了ycsb.sh程序 因此使用 ./ycsb进行执行,测试leveldb性能 12./ycsb load basic -P workloads/workloada./ycsb run basic -P workloads/workloada]]></content>
      <tags>
        <tag>leveldb</tag>
      </tags>
  </entry>
</search>
